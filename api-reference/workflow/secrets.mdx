---
title: Secrets
---

When you make calls to the [Unstructured Workflow Endpoint](/api-reference/workflow/overview), you might need to include a 
secret as part of the request. This secret is typically something such as the contents of a 
private key file that a third-party service requires for programmatic authentication. These secrets are 
typically required when creating  
[source connectors](/api-reference/workflow/source-connectors) or 
[destination connectors](/api-reference/workflow/destination-connectors) that work with specific third parties.

Instead of sending a secret to Unstructured programmatically in plain text, which presents a security risk, 
you must instead follow Unstructured's process for more securely sending the secret as follows:

1. Get the PEM version of the public key for your Unstructured user account.
2. Use this PEM to encrypt the secret locally.
3. Register the encrypted version of the secret with your Unstructured account. Unstructured returns a unique ID for the registered secret, 
   along with the type of encryption that was used.
4. Specify the registered secret's ID and encryption type in the call to the Unstructured Workflow Endpoint as needed.

The following sections describe how to complete the preceding process.

## Requirements

While you can use a REST API client such as `curl` or Postman to complete most of the following steps, you can only use Python to 
complete the step of encrypting the secret locally. Otherwise, both approaches are shown for the other steps.

To complete the following steps, you must have the following:

* Python installed on your local development machine.
* Optionally, a REST API client such as `curl` or Postman installed on your local development machine.
* An Unstructured account, including a valid Unstructured API key for that account.
* The following examples assume that you have the following two environment variables set locally:

  - `UNSTRUCTURED_API_URL`, set to the Workflow Endpoint API URL for your Unstructured user account.
  - `UNSTRUCTURED_API_KEY`, set to the API key for your Unstructured user account.

## Step 1: Get the PEM version of the public key

<AccordionGroup>
    <Accordion title="Python">
        The following Python code examples assumes that you have installed the following packages into your 
        Python virtual environment:

        - `requests`

        The following function returns the PEM version of the private key for your Unstructured user account:

        ```python
        import requests
        import os

        def get_public_key_pem() -> str:
            """
            Gets the PEM version of the public key for the calling Unstructured user.
            
            Args:
                None.

            Returns:
                str: A string representation of the user's public key.
            """
                
            headers = {
                "unstructured-api-key": os.getenv("UNSTRUCTURED_API_KEY"),
                "Accept": "application/json",
                "Content-Type": "application/json"
            }

            encryption_key_response = requests.request(
                method="POST",
                url=f"{os.getenv("UNSTRUCTURED_API_URL")}/api/v1/users/retrieve",
                headers=headers
            )

            encryption_public_key = encryption_key_response.json().get("pem_key")
            
            return encryption_public_key
        ```

        You could call this function as follows:

        ```python
        public_key = get_public_key_pem()

        print(public_key)
        ```

        The function returns the public key in PEM format.
    </Accordion>
    <Accordion title="curl">
        ```bash
        curl --request 'POST' --location \
        "$UNSTRUCTURED_API_URL/users/retrieve" \
        --header 'accept: application/json' \
        --header "unstructured-api-key: $UNSTRUCTURED_API_KEY" \
        | jq .pem_key
        ```
    </Accordion>
    <Accordion title="Postman">
        - ...

    </Accordion>
</AccordionGroup>

## Step 2: Encrypt the secret

<AccordionGroup>
    <Accordion title="Python">
        The following Python code examples assumes that you have installed the `cryptography` package into your 
        Python virtual environment.

        The following function encrypts a string by using envelope encryption. You must supply the function with the 
        PEM version of the public key for your Unstructured user account that you got from the previous step, and the plain-text version 
        of the secret that you need to encrypt.

        ```python
        from cryptography.hazmat.primitives.asymmetric import padding, rsa
        from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
        from cryptography.hazmat.backends import default_backend
        import os
        import base64

        def envelope_encrypt(public_key_pem: str, plaintext: str) -> dict:
            """
            Encrypts a string by using envelope encryption.
            
            Args:
                public_key_pem (str): The public key in PEM format.
                plaintext (str): The string to encrypt.

            Returns:
                dict: A dictionary with the encrypted AES key, iv, and ciphertext (all Base64-encoded).
            """

            # Load the public RSA key.
            public_key = serialization.load_pem_public_key(
                public_key_pem.encode('utf-8'),
                backend=default_backend()
            )

            # Generate a random AES key.
            aes_key = os.urandom(32)  # 256-bit AES key.

            # Generate a random IV.
            iv = os.urandom(16)

            # Encrypt by using AES-CFB.
            cipher = Cipher(
                algorithms.AES(aes_key),
                modes.CFB(iv),
            )

            encryptor = cipher.encryptor()
            ciphertext = encryptor.update(plaintext.encode('utf-8')) + encryptor.finalize()
            
            # Encrypt the AES key by using the RSA public key.
            encrypted_key = public_key.encrypt(
                aes_key,
                padding.OAEP(
                    mgf=padding.MGF1(algorithm=hashes.SHA256()),
                    algorithm=hashes.SHA256(),
                    label=None
                )
            )

            # Return all encrypted components, Base64-encoded.
            return {
                'encrypted_aes_key': base64.b64encode(encrypted_key).decode('utf-8'),
                'aes_iv': base64.b64encode(iv).decode('utf-8'),
                'encrypted_value': base64.b64encode(ciphertext).decode('utf-8'),
                'type': 'rsa_aes',
            }
        ```

        You could call the preceding `envelope_encrypt`function as follows. The following example extracts the contents of the specified 
        private key file as plain text and then passes it to the preceding `envelope_encrypt` function along 
        with the PEM version of the public key for your Unstructured user account.

        ```python
        import json

        google_drive_creds_json_file = "/Users/<username>/Downloads/<creds-json-file-name>.json"

        with open(google_drive_creds_json_file, "r") as f:
            google_json = json.load(f)
            secret_account_key = json.dumps(google_json)

        # Get the PEM version of the private key for your Unstructured user account.
        public_key_pem = get_public_key_pem()

        encrypted_secret = envelope_encrypt(
            public_key_pem=public_key_pem,
            plaintext=secret_account_key
        )

        print(encrypted_secret)
        ```

        The result of printing the encrypted secret that is returned looks similar to the following:

        ```bash
        {
            "encrypted_aes_key": "...",
            "aes_iv": "...",
            "encrypted_value": "...",
            "type": "rsa_aes"
        }
        ```

    </Accordion>
</AccordionGroup>

## Step 3: Register the encrypted secret

<AccordionGroup>
    <Accordion title="Python">
        The following Python code examples assumes that you have installed the following packages into your 
        Python virtual environment:

        - `requests`

        The following function returns the secret's registration code payload:

        ```python
        import requests
        import os

        def register_secret(encrypted_secret: dict) -> dict:
            """
            Registers an encrypted secret in the caller's Unstructured account and then 
            gets the secret's registration code payload.
            
            Args:
                encrypted_secret (dict): The encrypted secret to register.

            Returns:
                dict: The secret's registration code payload.
            """

            headers = {
                "unstructured-api-key": os.getenv("UNSTRUCTURED_API_KEY"),
                "Accept": "application/json",
                "Content-Type": "application/json"
            }

            create_secret_response = requests.request(
                method="POST",
                url=f"{os.getenv("UNSTRUCTURED_API_URL")}/api/v1/users/secrets",
                headers=headers,
                json=encrypted_secret
            ).json()
            
            return create_secret_response
        ```

        You could call this function as follows:

        ```python
        import json

        google_drive_creds_json_file = "/Users/<username>/Downloads/<creds-json-file-name>.json"

        with open(google_drive_creds_json_file, "r") as f:
            google_json = json.load(f)
            secret_account_key = json.dumps(google_json)

        # Get the PEM version of the private key for your Unstructured user account.
        public_key_pem = get_public_key_pem()

        encrypted_secret = envelope_encrypt(
            public_key_pem=public_key_pem,
            plaintext=secret_account_key
        )

        secret_payload = register_secret(
            encrypted_secret=encrypted_secret
        )

        print(secret_payload)
        ```
    </Accordion>
    <Accordion title="curl">
        ```bash
        curl --request 'POST' --location \
        "$UNSTRUCTURED_API_URL/users/secrets" \
        --header 'accept: application/json' \
        --header 'Content-Type: application/json' \
        --header "unstructured-api-key: $UNSTRUCTURED_API_KEY" \
        --data \
        '{
            "encrypted_value": "<encrypted-value>",
            "type": "rsa",
            "encrypted_aes_key": "<encrypted-aes-key>",
            "aes_iv": "<aes-iv>"
        }' \
        | jq .
        ```
    </Accordion>
    <Accordion title="Postman">
        - ...

    </Accordion>
</AccordionGroup>

## Step 4: Use the registered secret's ID and encryption type

<AccordionGroup>
    <Accordion title="Python">
        ```python

        ```
    </Accordion>
    <Accordion title="curl">
        ```bash
        curl --request 'POST' --location \
        "$UNSTRUCTURED_API_URL/sources" \
        --header 'accept: application/json' \
        --header "unstructured-api-key: $UNSTRUCTURED_API_KEY" \
        --header 'content-type: application/json' \
        --data \
        '{
            "name": "<name>",
            "type": "google_drive",
            "config": {
                "drive_id": "<drive-id>",
                "service_account_key": {
                    "id": "<registration-code>",
                    "type": "rsa_aes"
                }
            }
        }'
        ```
    </Accordion>
    <Accordion title="Postman">
        - ...

    </Accordion>
</AccordionGroup>